> **出典**: Perplexityで生成。元論文: LLM-Traders (JSAI2024)
> **ファクトチェック**: LLM-Traders論文の概念は正確に反映。DummyLLMClientは実際にはルールベースの疑似実装であり、LLMは使用していない点に注意。実運用にはOpenAI/Anthropic等のAPI差し替えが必要。

# それでは、内容を分析して、システムトレードに応用する目的で、Pythonのサンプルコードと解説マークダウンを出力してください。

LLM-Traders のアイデアを取り入れた「LLM を用いた JPX 系システムトレード用のサンプル（疑似実装）」を示します。[^1][^2][^3]

***

## 前提と設計方針（LLM-Traders からの抽出要素）

論文の要点を、実装に落としやすい形に整理すると以下になります。[^4][^1]

- LLM を「金融時系列の特徴を理解したモデル」として使う（fine-tuning）
- 市場状態や特徴量をテキスト化して与える「プロンプト設計」
- 複数プロンプト（視点）の結果を「動的アンサンブル」して最終シグナルを出す
- 実験では JPX Tokyo Stock Exchange Prediction データセットを用い、Lasso/LightGBM/RandomForest などより精度が良かったと報告されている。[^2][^3]

ここでは次のような簡略版を Python で組みます。

1. Kaggle JPX データ（の代替として CSV）から特定銘柄の価格時系列をロード
2. テクニカル指標を計算し、市場状態を自然言語に変換
3. 複数プロンプトで LLM に「明日の上昇確率」などを聞く
4. 応答をスコア化し、アンサンブルして売買シグナルを出す
5. シンプルなバックテストで性能を確認

※ 実際の LLM API（OpenAI/Anthropic など）の部分は「ダミー関数」にしてあり、そこだけ差し替えればそのまま使える構成にしています。

***

## Python サンプルコード（LLM-Traders 風フレームワーク）

```python
import pandas as pd
import numpy as np
from dataclasses import dataclass
from typing import List, Dict, Any, Callable
import datetime as dt

# ==============
# ユーティリティ
# ==============

def calc_technical_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    df: 必須カラム ['Date', 'Close']
    """
    df = df.sort_values("Date").copy()
    df["ret_1d"] = df["Close"].pct_change()
    df["ma_5"] = df["Close"].rolling(5).mean()
    df["ma_20"] = df["Close"].rolling(20).mean()
    df["vol_20"] = df["Close"].pct_change().rolling(20).std()
    df["ma_ratio_5_20"] = df["ma_5"] / df["ma_20"]
    df["drawdown"] = df["Close"] / df["Close"].cummax() - 1.0
    df["target_up"] = (df["Close"].shift(-1) > df["Close"]).astype(int)
    return df

def describe_market_state(row: pd.Series) -> str:
    """
    1行の特徴量から、市場状態を自然言語で記述。
    LLM に渡すテキストの一部として利用。
    """
    desc = []

    # トレンド
    if row["ma_ratio_5_20"] > 1.02:
        desc.append("短期移動平均は長期移動平均よりかなり上にあり、上昇トレンドが継続している。")
    elif row["ma_ratio_5_20"] < 0.98:
        desc.append("短期移動平均は長期移動平均よりかなり下にあり、下降トレンドが継続している。")
    else:
        desc.append("短期と長期の移動平均は近く、はっきりしたトレンドはない。")

    # ボラティリティ
    if row["vol_20"] > 0.03:
        desc.append("直近20日のボラティリティは高く、価格変動が大きい。")
    elif row["vol_20"] < 0.01:
        desc.append("直近20日のボラティリティは低く、価格変動は比較的小さい。")
    else:
        desc.append("直近20日のボラティリティは中程度である。")

    # ドローダウン
    if row["drawdown"] < -0.15:
        desc.append("過去の高値からのドローダウンが大きく、調整局面の可能性がある。")
    elif row["drawdown"] > -0.05:
        desc.append("過去の高値に近い水準にあり、強い相場が続いている。")
    else:
        desc.append("やや調整が進んでいるが、極端な下落ではない。")

    return " ".join(desc)

# ===================
# LLM インターフェース
# ===================

@dataclass
class LLMConfig:
    model_name: str
    temperature: float = 0.0

class DummyLLMClient:
    """
    実際の LLM API を呼び出す部分のダミー。
    実運用ではここを OpenAI / Anthropic / その他 API に差し替える。
    """

    def __init__(self, config: LLMConfig):
        self.config = config

    def generate(self, prompt: str) -> str:
        # 実際にはここで API 呼び出しを行う
        # --------------------------------------------------
        # ここではサンプルとして簡易ルールベースで擬似スコアを返す
        # --------------------------------------------------
        score = 0.5
        if "上昇トレンド" in prompt:
            score += 0.2
        if "下降トレンド" in prompt:
            score -= 0.2
        if "ボラティリティは高く" in prompt:
            score -= 0.05
        if "ボラティリティは低く" in prompt:
            score += 0.05
        score = max(0.0, min(1.0, score))
        return f"明日1日の終値が今日より高くなる確率はおよそ {score:.2f} です。"


# =====================
# プロンプト設計と解析
# =====================

def build_prompt_style_1(symbol: str, date: dt.date, state_text: str) -> str:
    return f"""
あなたは株式トレーダーとして行動します。
銘柄: {symbol}
日付: {date.isoformat()}

市場状態の説明:
{state_text}

タスク:
明日1日の終値が今日の終値より高くなる確率を、0から1の実数で推定してください。
確率のみを返してください。
"""

def build_prompt_style_2(symbol: str, date: dt.date, state_text: str) -> str:
    return f"""
You are a quantitative trader.
Ticker: {symbol}
Date: {date.isoformat()}

Market condition summary:
{state_text}

Question:
Estimate the probability (from 0.0 to 1.0) that tomorrow's close price will be higher than today's close price.
Respond ONLY with a number.
"""

def parse_probability_from_response(text: str) -> float:
    """
    応答テキストから [0,1] の確率を抽出する簡易パーサ。
    """
    import re

    nums = re.findall(r"[0-1]\.\d+", text)
    if not nums:
        # 0 or 1 のような整数だけ返るケースも考慮
        ints = re.findall(r"\b[^01]\b", text)
        if ints:
            return float(ints[^0])
        return 0.5
    return float(nums[^0])

# ======================
# 動的アンサンブル（簡略版）
# ======================

def dynamic_ensemble(prob_list: List[float], vol: float) -> float:
    """
    複数プロンプトからの確率を重み付き平均する簡易版アンサンブル。
    例として「ボラが高いほど保守的に中心（0.5）に寄せる」ように調整。
    """
    base_prob = float(np.mean(prob_list))
    # ボラティリティに応じて縮小
    shrink = min(1.0, max(0.0, vol / 0.05))  # vol=0〜5% -> 0〜1
    ensemble_prob = 0.5 + (base_prob - 0.5) * (1.0 - 0.5 * shrink)
    return ensemble_prob

def prob_to_signal(prob: float, upper=0.6, lower=0.4) -> int:
    """
    確率から売買シグナルを決定。
    1: ロング, -1: ショート, 0: ノーポジ
    """
    if prob >= upper:
        return 1
    elif prob <= lower:
        return -1
    else:
        return 0

# ======================
# バックテスト（デイリー）
# ======================

def backtest_llm_trader(
    df: pd.DataFrame,
    symbol: str,
    llm_client: DummyLLMClient,
    prompt_builders: List[Callable[[str, dt.date, str], str]],
) -> pd.DataFrame:
    """
    df: 単一銘柄の時系列（calc_technical_features 済み）
    """
    df = df.copy()
    df["signal"] = 0
    df["prob"] = np.nan

    for i in range(len(df) - 1):  # 最終日はターゲットがないので除外
        row = df.iloc[i]
        date = row["Date"].date() if isinstance(row["Date"], pd.Timestamp) else row["Date"]
        state_text = describe_market_state(row)

        probs = []
        for build_prompt in prompt_builders:
            prompt = build_prompt(symbol, date, state_text)
            resp = llm_client.generate(prompt)
            p = parse_probability_from_response(resp)
            probs.append(p)

        prob_ens = dynamic_ensemble(probs, vol=row["vol_20"])
        sig = prob_to_signal(prob_ens)

        df.loc[df.index[i], "prob"] = prob_ens
        df.loc[df.index[i], "signal"] = sig

    # 翌日のリターンに対してシグナルを適用
    df["next_ret"] = df["Close"].pct_change().shift(-1)
    df["strategy_ret"] = df["signal"] * df["next_ret"]
    df["equity_curve"] = (1 + df["strategy_ret"].fillna(0)).cumprod()

    return df

# ==============
# 使い方例
# ==============

if __name__ == "__main__":
    # 1. データ読み込み (例: JPX データから単一銘柄だけ抽出した CSV)
    # CSV には ['Date', 'Close'] があると仮定
    data = pd.read_csv("sample_jpx_single_symbol.csv")
    data["Date"] = pd.to_datetime(data["Date"])

    data_feat = calc_technical_features(data)
    data_feat = data_feat.dropna().reset_index(drop=True)

    # 2. LLM クライアント（ダミー）
    llm = DummyLLMClient(LLMConfig(model_name="dummy-llm"))

    # 3. バックテスト
    prompt_builders = [build_prompt_style_1, build_prompt_style_2]
    bt = backtest_llm_trader(
        df=data_feat,
        symbol="SAMPLE",
        llm_client=llm,
        prompt_builders=prompt_builders,
    )

    print(bt[["Date", "Close", "prob", "signal", "strategy_ret", "equity_curve"]].tail())
```


***

## 解説用マークダウン（ドキュメント用）

```markdown
# LLM-Traders 風システムトレード実装メモ

## 1. 目的

- LLM-Traders 論文で提案されている「LLM + プロンプトエンジニアリング + 動的アンサンブル」の考え方を、  
  シンプルな Python 実装として再現し、システムトレードで利用できる形にする。  
- 本実装では JPX Tokyo Stock Exchange Prediction データセットを想定しつつ、  
  単一銘柄の終値データを用いた日次トレード戦略を構築する。

## 2. 全体アーキテクチャ

1. データ前処理  
   - 日付順にソート  
   - 1日リターン、5日/20日移動平均、20日ボラティリティ、ドローダウンなどの特徴量を計算  
   - 翌日の終値が今日より高いかどうかのラベル (target_up) を生成  

2. 市場状態のテキスト化  
   - 各日の特徴量から、「上昇トレンド/下降トレンド/レンジ」「ボラティリティ水準」「ドローダウンの大きさ」を  
     自然言語で記述する関数 `describe_market_state` を定義。  
   - これは LLM に渡す入力テキストの一部となり、LLM のファインチューニングや推論時のコンテキストとして働く。

3. プロンプト設計  
   - 日本語スタイルのプロンプト（スタイル1）と、英語スタイルのプロンプト（スタイル2）を用意。  
   - どちらも「明日の終値が今日より高くなる確率を 0〜1 で出力せよ」というタスクを明示。  
   - プロンプトの多様性により、LLM の応答を複数の視点から得ることを意図する。

4. LLM インターフェース  
   - サンプルでは `DummyLLMClient` を用い、特徴的なキーワードに反応して擬似的な確率を返す。  
   - 実運用では、このクラスを OpenAI / Anthropic / その他の LLM API クライアントに置き換える。  
   - 応答テキストから 0〜1 の実数値を抽出するための `parse_probability_from_response` 関数を用意。

5. 動的アンサンブル  
   - 複数プロンプトから得た確率の平均をベースとし、20日ボラティリティに応じて中心 (0.5) に縮小する関数 `dynamic_ensemble` を定義。  
   - ボラティリティが高いほど予測を保守的にすることで、過剰なポジションリスクを抑えるイメージ。  
   - しきい値 (例: 0.6, 0.4) に基づき、ロング/ショート/ノーポジのシグナルを決定。

6. バックテスト  
   - 各営業日に対して LLM による確率推定とシグナル生成を行い、翌日のリターンを掛け合わせて戦略リターンを計算。  
   - 累積リターンを `equity_curve` として算出し、ベンチマーク（単純ホールド）などと比較して性能評価を行う。  

## 3. 実運用に向けた拡張ポイント

- **LLM のファインチューニング**  
  - 論文では、金融時系列と関連するタスクで LLM を追加学習することで、ノイズの多いデータへの過学習を抑えつつ、  
    構造的なパターンを捉えることを狙っている。  
  - 実装レベルでは、過去の価格系列とその後の価格方向ラベルをテキスト形式に変換し、  
    「このような市場状態では翌日は上昇/下落」という教師データで指示チューニングを行うアプローチが考えられる。

- **プロンプトの多様化と自動生成**  
  - ファンダメンタル情報やニュース要約、他銘柄との相関情報などをテキストに組み込むことで、  
    LLM がより多面的に市場を捉えられるようにする。  
  - プロンプトテンプレートを多数用意し、日次・週次で切り替えることで、  
    論文でいう「動的アンサンブル」に近い振る舞いを再現できる。

- **リスク管理とポートフォリオ構築**  
  - 単一銘柄だけでなく、複数銘柄の確率を同時に推定し、  
    上位 n 銘柄をロング、下位 n 銘柄をショートするロングショートポートフォリオを構築する。  
  - ボラティリティや相関に基づくポジションサイズ調整（ボラティリティ・スケーリング、リスクパリティなど）を組み合わせる。

- **評価指標の多様化**  
  - 単純な Accuracy や相関だけでなく、シャープレシオ、最大ドローダウン、トレード回転率など、  
    実運用を意識した指標で評価する。  

## 4. 注意点

- LLM をトレードに利用する場合、過去データに特化したプロンプトやチューニングを行うと、  
  過学習やリーク（未来情報の混入）に繋がるリスクがある。  
- 競合コンペデータ（Kaggle JPX など）を使う際は、公開ルールや利用規約を守ること。  
- 実資金運用前には、十分なウォークフォワードテストやストレステストを行うことが不可欠である。
```


***

## 実運用に向けた次ステップの例

- JPX コンペの `prices.csv` から特定銘柄を抽出する前処理スクリプトを追加し、`sample_jpx_single_symbol.csv` を自動生成する。[^5][^3]
- DummyLLMClient を、手元の LLM API（例: OpenAI GPT-4 系、Claude 3.5 系など）に置き換えた上で、実際に確率を出し、バックテスト結果を検証する。
- マルチ銘柄対応版（複数コードに対して同じフレームワークを適用し、ポートフォリオを組む版）に拡張する。

この方向性で「自分の口座・制約」に合わせた設計に落としていくことが、論文の枠組みを実戦シストレに接続する一番現実的な進め方になると思います。[^1][^2]
<span style="display:none">[^10][^11][^12][^13][^14][^15][^6][^7][^8][^9]</span>

<div align="center">⁂</div>

[^1]: https://www.jstage.jst.go.jp/article/pjsai/JSAI2024/0/JSAI2024_3Xin283/_article/-char/ja

[^2]: https://techblog.insightedge.jp/entry/JSAI2024-review

[^3]: https://www.kaggle.com/competitions/jpx-tokyo-stock-exchange-prediction/data

[^4]: https://www.jstage.jst.go.jp/article/pjsai/JSAI2024/0/JSAI2024_3Xin283/_article/-char/en

[^5]: https://note.com/sirteabear/n/nc4466135a619

[^6]: https://cir.nii.ac.jp/crid/1390863395972546816

[^7]: https://jxiv.jst.go.jp/index.php/jxiv/preprint/view/1268

[^8]: https://sbiferi.co.jp/assets/pdf/review/review_vol08_03_202508.pdf

[^9]: https://weblab.t.u-tokyo.ac.jp/lecture/course-list/financial-machin-learning/

[^10]: https://eudl.eu/pdf/10.4108/eai.26-5-2023.2334222

[^11]: https://jglobal.jst.go.jp/detail?JGLOBAL_ID=202402216322528005

[^12]: https://blog.csdn.net/xiuxiuxiu666/article/details/125877329

[^13]: https://eudl.eu/doi/10.4108/eai.19-5-2023.2334371

[^14]: https://www.dir.co.jp/report/research/economics/outlook/20241101_024715.pdf

[^15]: https://arxiv.org/pdf/2502.11433.pdf

